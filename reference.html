<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
  <meta name="keywords" content="VHDL, HDL" />
  <meta name="description" content="Reference Information for VHSIC Hardware Description Language (VHDL)">
  <meta name="author" content="Adam Perkins">
  <!--<link rel="icon" href="../../favicon.ico">-->
  <title>vhdl.io - VHDL Reference Information - Reference</title>

  <!-- Bootstrap -->
  <link href="bootstrap-3.3.7/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Custom styles for this template -->
  <link href="StyleSheets/sidebar.css" rel="stylesheet">

  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
  <!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script> -->
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="bootstrap-3.3.7/dist/js/bootstrap.min.js"></script>
  <!-- JS code highlighting -->
  <link href="CodeHighlighting/styles/atom-one-light.css" rel="stylesheet">
  <script src="CodeHighlighting/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script src="js/sidebar_highlight.js"></script>
</head>

<body>

  <!-- Top Navigation for overall site -->
  <nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar">Reference</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        <a class="navbar-brand" href="index.html">vhdl.io</a>
      </div>
      <div id="navbar" class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
          <li class="active"><a href="reference.html">Reference</a></li>
          <li><a href="sample.html">Sample</a></li>
          <li><a href="about.html">About</a></li>
          <li><a href="contact.html">Contact</a></li>
        </ul>
      </div>
      <!--/.nav-collapse -->
    </div>
  </nav>

  <!-- Main page contents -->
  <div id="wrapper">

    <!-- Sidebar -->
    <div id="sidebar-wrapper">
      <nav id="spy" data-spy="affix">
        <ul class="sidebar-nav nav" id="sidebar">
          <li><a href="#Definitions">Definitions</a></li>
          <li><a href="#Aggregates">Aggregates</a></li>
          <li><a href="#Alias_Declaration">Alias Declaration</a></li>
          <li><a href="#Architecture">Architecture</a></li>
          <li><a href="#Arrays">Arrays</a></li>
          <li><a href="#Assert">Assert</a></li>
          <li><a href="#Attributes">Attributes</a></li>
          <li><a href="#Block_Statement">Block Statement</a></li>
          <li><a href="#Case_Statement">Case Statement</a></li>
          <li><a href="#Component_Declaration">Component Declaration</a></li>
          <li><a href="#Component_Instantiation">Component Instantiation</a></li>
          <li><a href="#Configuration_Declaration">Configuration Declaration</a></li>
          <li><a href="#Configuration_Specification">Configuration Specification</a></li>
          <li><a href="#Constant_Declaration">Constant Declaration</a></li>
          <li><a href="#Entity">Entity</a></li>
          <li><a href="#Exit_Statement">Exit Statement</a></li>
          <li><a href="#File_Declaration">File Declaration</a></li>
          <li><a href="#For_Loop">For Loop</a></li>
          <li><a href="#Functions">Functions</a></li>
          <li><a href="#Generate_Statement">Generate Statement</a></li>
          <li><a href="#Generics">Generics</a></li>
          <li><a href="#If_Statement">If Statement</a></li>
          <li><a href="#Literals">Literals</a></li>
          <li><a href="#Names">Names</a></li>
          <li><a href="#Next_Statement">Next Statement</a></li>
          <li><a href="#Null_Statement">Null Statement</a></li>
          <li><a href="#Operators">Operators</a></li>
          <li><a href="#Package">Package</a></li>
          <li><a href="#Package_Body">Package Body</a></li>
          <li><a href="#Procedures">Procedures</a></li>
          <li><a href="#Process">Process</a></li>
          <li><a href="#Qualified_Expressions">Qualified Expressions</a></li>
          <li><a href="#Signal_Assignment-Concurrent">Signal Assignment - Concurrent</a></li>
          <li><a href="#Signal_Assignment-Conditional">Signal Assignment - Conditional</a></li>
          <li><a href="#Signal_Assignment-Sequential">Signal Assignment - Sequential</a></li>
          <li><a href="#Signal_Declaration">Signal Declaration</a></li>
          <li><a href="#Subtype_Declaration">Subtype Declaration</a></li>
          <li><a href="#Type_Conversion">Type Conversion</a></li>
          <li><a href="#Type_Declaratio">Type Declaration</a></li>
          <li><a href="#Use_Clause">Use Clause</a></li>
          <li><a href="#Variable_Declaration">Variable Declaration</a></li>
          <li><a href="#Variable_Assignment">Variable Assignment</a></li>
          <li><a href="#Wait_Statement">Wait Statement</a></li>
          <li><a href="#While_and_Infinite_Loop">While and Infinite Loop</a></li>
        </ul>
      </nav>
    </div>
    <!-- /#sidebar-wrapper -->

    <!-- Page Content -->
    <div id="page-content-wrapper">
      <div class="page-content inset" data-spy="scroll" data-target="#spy">
        <div class="row">
          <div class="col-lg-12">
            <!-- Definitions -->
            <div  id="Definitions">
            <h2>Definitions</h2>
              <table class="table table-bordered">
                <tbody>
                  <tr>
                    <td>Analysis</td>
                    <td>The syntax checking and compilation of a VHDL design into a design library.</td>
                  </tr>

                  <tr>
                    <td valign="center">Architecture</td>
                    <td>A library unit associated with an entity which describes its internal operation or organisation. Multiple architectures may be defined for a single entity</td>
                  </tr>

                  <tr>
                    <td>Component</td>
                    <td>A definition of the interface to a sub-module, rather like a "socket", to which an entity may later be bound.</td>
                  </tr>

                  <tr>
                    <td>Concurrent Statements</td>
                    <td>Statements within an architecture which execute concurrently in simulated time, independently of their order.</td>
                  </tr>

                  <tr>
                    <td>Configuration</td>
                    <td>Defines the "binding" of each component instance to an entity, and each entity to an architecture. Can be defined using a configuration library unit or from within an architecture.</td>
                  </tr>

                  <tr>
                    <td>Design File</td>
                    <td>A text file containing source code for one or more design units.</td>
                  </tr>

                  <tr>
                    <td>Design Library</td>
                    <td>A data structure containing analysed design units (library units).</td>
                  </tr>

                  <tr>
                    <td>Design Unit</td>
                    <td>A VHDL module contained in a design file, consisting of the source code for a library unit preceded by any required Library or Use clauses. Analysis of a design unit defines the corresponding library unit in a design library.</td>
                  </tr>

                  <tr>
                    <td>Elaboration</td>
                    <td>The building of a simulateable model through the top-down binding of its structural hierarchy, according to the configuration selected.</td>
                  </tr>

                  <tr>
                    <td>Entity</td>
                    <td>A library unit which describes the external interface of a hardware module.</td>
                  </tr>

                  <tr>
                    <td>Function</td>
                    <td>A group of sequential statements which can be "called" from different places in a model, reading one or more input parameters and returning a single value.</td>
                  </tr>

                  <tr>
                    <td>Library Unit</td>
                    <td>An analysed design unit. The five types of library unit are: entity, architecture, package, package body and configuration.</td>
                  </tr>

                  <tr>
                    <td>Overloading</td>
                    <td>The definition of multiple functions or procedures with the same name, which operate on different parameter combinations or types.</td>
                  </tr>

                  <tr>
                    <td>Package</td>
                    <td>A primary unit containing a collection of declarations and/or specifications which may be used in other library units.</td>
                  </tr>

                  <tr>
                    <td>Package Body</td>
                    <td>A secondary unit associated with a package, whose main purpose is to contain the full code for any functions or procedures which have been declared in the associated package. It may also contain declarations and specifications which are explained in the Reference Guide section of this document.</td>
                  </tr>

                  <tr>
                    <td>Primary Unit</td>
                    <td>a library unit which can exist in a design library. The primary design units are entity, package and configuration.</td>
                  </tr>

                  <tr>
                    <td>Procedure</td>
                    <td>A group of sequential statements which can be "called" from different places in a model. It may have parameters of modes in, out or inout.</td>
                  </tr>

                  <tr>
                    <td>Process</td>
                    <td>A concurrent statement which contains a collection of sequential statements and which can interact concurrently with other concurrent statements.</td>
                  </tr>

                  <tr>
                    <td>Resolution</td>
                    <td>The determination of the value of a signal when it is simultaneously driven by more than one source.</td>
                  </tr>

                  <tr>
                    <td>Scope</td>
                    <td>The region of VHDL code within which a declared item (e.g. a constant) may be used</td>
                  </tr>

                  <tr>
                    <td>Secondary Unit</td>
                    <td>A library init which defines a body associated with a primary unit which has already been analysed into the same design library. The secondary units are architecture (associated with entity) and package body (associated with package).</td>
                  </tr>

                  <tr>
                    <td>Sequential Statements</td>
                    <td>Statements which are executed in the order they are written, as with "conventional" software languages.</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <!-- Aggregates -->
            <div  id="Aggregates">
            <h2>Aggregates</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Expression</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Entity<br>Architecture<br>Package<br>Package Body</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">(value_1, value_2, ...)</code></pre>
                <pre><code class="vhdl">(element_1 =&gt; value_1, element_2 =&gt; value_2, ...)</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">

Aggregates are a grouping of values to form an array or record expression. The first form is called <b>positional association</b>, where the values are associated with elements from left to right:
<pre><code class="vhdl">signal Z_BUS : bit_vector(3 downto 0);
signal A_BIT, B_BIT, C_BIT, D_BIT : bit;
...
Z_BUS &lt;= (A_BIT, B_BIT, C_BIT, D_BIT);</code></pre>

Equivalent Assignments:
<pre><code class="vhdl">Z_BUS(3) &lt;= A_BIT;
Z_BUS(2) &lt;= B_BIT;
Z_BUS(1) &lt;= C_BIT;
Z_BUS(0) &lt;= D_BIT;</code></pre>
Aggregates may be used as the targets of assignments.<br><br>

The second form is <b>named association</b>, where elements are explicitly referenced and order is not important:
<pre><code class="vhdl">signal Z_BUS : bit_vector(3 downto 0);
signal A_BIT, B_BIT, C_BIT, D_BIT : bit;
...
Z_BUS &lt;= (2 =&gt; B_BIT, 1 =&gt; C_BIT, 0 =&gt; D_BIT, 3 =&gt; A_BIT);</code></pre>

With positional association, elements may be grouped together using the | symbol or a range. The keyword <b>others</b> may be used to refer to all elements not already mentioned:
<pre><code class="vhdl">signal B_BIT : bit;
signal BYTE : bit_vector(7 downto 0);
...
BYTE &lt;= (7 =&gt; '1', (5 downto 1) =&gt; '1', 6 =&gt; B_BIT, (others =&gt; '0'));</code></pre>

Assignment to a whole record must be done using an aggregate. Positional or named association may be used.
<pre><code class="vhdl">type T_PACKET is record
  BYTE_ID : std_ulogic;
  PARITY  : std_ulogic;
  ADDRESS : integer range 0 to 3;
  DATA    : std_ulogic_vector(3 downto 0);
end record
signal TX_DATA : T_PACKET;
...
TX_DATA &lt;= ('1', '0', 2, "0101");</code></pre>

An aggregate containing just <b>others</b> can assign a value to all elements of an array, regardless of size:
<pre><code class="vhdl">type NIBBLE is array (3 downto 0) of std_ulogic;
type MEM is array (0 to 7) of NIBBLE;
variable MEM8X4: MEM := (others =&gt; "0000");
variable D_BUS : std_ulogic_vector(63 downto 0) := (others =&gt; 'Z');</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Logic synthesis tools may not support named association fully. Also, record assignments using aggregates may not be supported.
              </div>
            </div>
          </div>

            <!-- ALIAS DECLARATION -->
            <div  id="Alias_Declaration">
            <h2>Alias Declaration</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Declaration</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Entity<br>Package<br>Process<br>Architecture<br>Procedure<br>Function</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">alias alias_name : alias_type is object_name;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">

An alias is an alternative name for an existing object (signal, variable or constant). It does not define a new object.
<pre><code class="vhdl">alias SIGN    : bit is DATA(31);
alias BYTE_ID : bit is NET_DATA_IN(7);</code></pre>

Aliases provide a useful "shorthand" for referencing complex slices etc.:
<pre><code class="vhdl">use work.BV_ARITH.all;
...
alias OPERAND : bit_vector(1 downto 0) is CPU_BUFFER(LOW) (4 downto 3);
alias A       : bit_vector(3 downto 0) is CPU_BUFFER(HIGH)(3 downto 0);
alias B       : bit_vector(2 downto 0) is CPU_BUFFER(LOW) (2 downto 0);
...
CPU_DATA_TMP := (B &amp; A) + OPERAND;</code></pre>

An alias of an array object can be indexed in the opposite direction.
<pre><code class="vhdl">signal BUS_A : std_ulogic_vector(7 downto 0);
alias BIT_REV_A : std_ulogic_vector(0 to 7) is BUS_A;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                <p>
                  Aliases are not supported by many logic synthesis tools.
                </p>
                <p>
                  A work-around is to declare new "alias" signals, variables or constants, and assign them with the slice expression. With signals and variables this increases simulation overhead, but preserves readability.
                </p>
                <p>
                  Such "alias" signals should be assigned concurrently, and "alias" variables should be reassigned each time their process is activated.
                </p>
              </div>
            </div>
          </div>

            <!-- ARCHITECTURE -->
            <div  id="Architecture">
            <h2>Architecture</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Secondary Unit</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">architecture architecture_name of entity_name is
  declarations
begin
  concurrent statements
end architecture architecture_name;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">

Declarations may typically be any of the following: type, subtype, signal, constant, file, alias, component, attribute, function, procedure, configuration specification.
<pre><code class="vhdl">architecture TB of TB_CPU is
  component CPU_IF
    port   -- port list
  end component;
  signal CPU_DATA_VALID: std_ulogic;
  signal CLK, RESET: std_ulogic := '0';
  constant PERIOD : time := 10 ns;
  constant MAX_SIM: time := 50 * PERIOD;
begin
  -- concurrent statements
end TB;</code></pre>

The order of concurrent statements is not important - behaviour is defined by data dependencies only:
<pre><code class="vhdl">architecture EX1 of CONC is
  signal Z, A, B, C, D : integer;
begin
  D &lt;= A + B;
  Z &lt;= C + D;
end EX1;</code></pre>

Items declared in an architecture are visible in any process or block within it.<br>

An equivalent architecture:
<pre><code class="vhdl">architecture EX2 of CONC is
  signal Z, A, B, C, D : integer;
begin
  Z &lt;= C + D;
  D &lt;= A + B;
end EX2;</code></pre>

An architecture can contain any mix of component instances, processes or other concurrent statements:
<pre><code class="vhdl">architecture TEST of TB_DFF is
  component DFF
    port (
      CLK, D: in  std_ulogic;
      Q     : out std_ulogic);
  end component;
  signal CLK, D, Q : std_ulogic := '0';
begin
  UUT: DFF port map (CLK, D, Q);

  CLK &lt;= not (CLK) after 25 ns;

  STIMULUS: process
  begin
    wait for 50 ns;
    D &lt;= '1';
    wait for 100 ns;
    D &lt;= '0';
    wait for 50 ns;
  end process STIMULUS;
end architecture TEST;</code></pre>

An entity can have one or more architectures. which one is used (or "bound") depends on the <b>configuration</b>.<br>

An architecture cannot be analysed unless the entity it refers to exists in the same design library.

              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                <p>
                  Architectures are fully supported by synthesis tools, provided the declarations and statements they contain are compatible with synthesis.
                </p>
                <p>
                  Configuration is not usualy supported by synthesis tools, so only one architecture per entity may be analysed. With some tools, this architecture must be in the same design file as the entity.
                </p>
              </div>
            </div>
          </div>

            <!-- ARRAYS -->
            <div  id="Arrays">
            <h2>Arrays</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Declaration</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Package<br>Entity<br>Architecture<br>Process<br>Procedure<br>Function</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">type type_name is array (range) of element_type;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
An <b>array</b> contains multiple elements of the same type. When an array object is declared, an existing array type must be used.
<pre><code class="vhdl">type NIBBLE is array (3 downto 0) of std_ulogic;
type RAM is array (0 to 31) of integer range 0 to 255;
signal A_BUS : NIBBLE;
signal RAM_0 : RAM;</code></pre>

An array type definition can be <b>unconstrained</b>, i.e. of undefined length. <b>String</b>, <b>bit_vector</b>, and <b>std_logic_vector</b> are defined in this way. An object (signal, variable, or constant) of an unconstrained array type must have it's index type range defined when it is declared.
<pre><code class="vhdl">type INT_ARRAY is array (integer range &lt;&gt;) of integer;
variable INT_TABLE: INT_ARRAY(0 to 9);
variable LOC_BUS : std_ulogic_vector(7 downto 0);</code></pre>

Arrays with character elements such as <b>string</b>, <b>bit_vector</b>, and <b>std_logic_vector</b> may be assigned a literal value using double quotes (see <b>literals</b>):
<pre><code class="vhdl">CONSTANT MSG_o: string := "Test 1 Completed";
...
A_BUS &lt;= "0000";
LOC_BUS &lt;= "10101010";</code></pre>

Arrays may also be assigned using <b>concatenation</b>, <b>aggregates</b>, <b>slices</b>, or a mixture. By default, assignment is made by <b>position.</b>
<pre><code class="vhdl">A_BUS &lt;= (A_BIT, B_BIT, C_BIT, D_BIT);
-- an equivalent assignment:
A_BUS &lt;= (A_BIT &amp; B_BIT &amp; C_BIT &amp; D_BIT);
-- rotate A_BUS to the left:
A_BUS &lt;= A_BUS(2 downto 0) &amp; A_BUS(3);</code></pre>

Arrays of arrays may be declared. These are useful for memories, vector tables, etc.:
<pre><code class="vhdl">type NIBBLE is array (3 downto 0) of std_ulogic;
type MEM is array (0 to 7) of NIBBLE;
-- an array "array of array" type
variable MEM8X4 : MEM;
...
-- accessing the whole array:
MEM8X4 := ("0000", "0001", "0010", "0011", "0100", "0101", "0110", "0111");
-- accessing a "word"
MEM8X4(5) := "0110";
-- accessing a single bit
MEM8X4(6) (0) := '0';</code></pre>

True two (or more) dimensional arrays may also be declared:
<pre><code class="vhdl">type T_2D is array (3 downto 0, 1 downto 0) of integer;
signal X_2D : T_2D;
...
X_2D &lt;= ((0,0), (1,1), (2,2), (3,3));
X_2D(3,1) &lt;= 4;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                <p>
                  Most logic synthesis tools accept one-dimensional <b>arrays</b> of other supported types. 1-D arrays of 1-D arrays are often supported. Some tols also allow true 2-D arrays, but not more dimensions.
                </p>
                <p>
                  Note that arrays are usually implemented using gates and flip-flops, not ROM's and RAM's.
                </p>
              </div>
            </div>
          </div>

            <!-- Assert -->
            <div  id="Assert">
            <h2>Assert</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Concurrent Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Entity<br>Architecture</td>
              </tr>
              <tr><td><br/></td></tr>
              <tr>
                <td bgcolor="lightcyan">Sequential Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Process<br>Function<br>Procedure</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">assert condition report string severity severity_level;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
The assert statement tests the boolean condition. If this is <b>false</b>, it outputs a message containing the report string to the simulator screen:
<pre><code class="vhdl">assert (J /= C) report "J = C" severity note;</code></pre>

The severity level may be defined as <b>note, warning, error</b> or <b>failure</b>
Level <b>failure</b> normally aborts the simulation.
<pre><code class="vhdl">assert not OVERFLOW report "Accumulator overflowed" severity failure;
</code></pre>

If the message clause is ommited, a default message is output.
The severity level and the name of the design unit containing the relevant assert
statement may also be output.

If the severity clause is ommited, the default level is <b>error.</b>

A <b>concurrent</b> statement monitors the boolean condition continuously.

An unconditional message can be output by using the literal <b>false</b>:
<pre><code class="vhdl">procedure
  PUT (
    signal STACK   : inout T_STACK;
    signal POINTER : inout T_POINT;
    signal ITEM    : in    T_DATA
  ) is
begin
  if (POINTER &lt; 5) then
    STACK(POINTER) &lt;= ITEM;
    POINTER &lt;= POINTER + 1;
  else
    assert false report "Stack overflow" severity error;
  end if;
end PUT;</code></pre>

As well as functional errors, timing errors can be reported via <b>assert</b>:
<pre><code class="vhdl">CHECK_SETUP : process (CLK, D)
begin
  if (CLK'event and CLK = '1') then
    assert D'stable(SETUP_TIME) report "Setup Violation..." severity warning;
  end if;
end process CHECK_SETUP;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Assert statements are ignored by logic synthesis tools.
              </div>
            </div>
          </div>

            <!-- Attributes -->
            <div  id="Attributes">
            <h2>Attributes</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Attribute</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Entity<br>Architecture<br>Package<br>Package Body</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">object'attribute_name</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
Attributes supply additional information about an item, e.g. a signal, variable, type or component. Certain attributes are predefined for types, array objects and signals.<br/>

These are some of the predefined attributes for scalar types, constrained array types and any objects declared to be of array types. They are the same type as the object (scalar), or the index (array):
<pre><code class="vhdl">X'high  -- The upper bound of X
X'low   -- The lower bound of X
X'left  -- The leftmost bound of X
X'right -- The rightmost bound of X</code></pre>

These are predefined only constrained array types and any objects declared to be of array types:
<pre><code class="vhdl">X'range -- The range of X
X'reverse_range -- The range of X "back to front"
X'length -- X'high - X'low + 1 (integer)</code></pre>

These attributes are predefined for any signal X:
<pre><code class="vhdl">X'event -- True when signal X changes (boolean)
X'active -- True when signal X assigned to (boolean)
X'last_event -- When signal X last changed (time)
X'last_active -- When signal X was last assigned to (time)
X'last_value -- Previous value of X (same type as X)</code></pre>

These attributes create a <b>new signal</b>, based on signal X:
<pre><code class="vhdl">X'delayed(T)Signal X delayed by T (same type as X)
X'stable(T) -- True if X unaltered for time T (boolean)
X'quiet(T) -- True if X is unassigned for time T (boolean)
X'transaction -- "Toggles" when X is assigned (bit)</code></pre>

User defined attributes may be declared. These do not affect simulation, but may be used to supply information to other tools, e.g. for layout or synthesis:
<pre><code class="vhdl">type IC_PACKAGE is (DIL, PLCC, PGA);
attribute PTYPE: ICPACKAGE;
attribute PTYPE of U1 : component is PLCC;
attribute PTYPE of U2 : component is DIL;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Logic synthesis tools usually support the predefined attributes <b>'high, 'low,
                'left, 'right, 'range, reverse_range, 'length</b> and <b>'event</b>. Some tools
                support <b>'last_value</b> and <b>'stable</b>.
                <br/><br/>
                Several synthesis vendors define a set of attributes to supply synthesis directives
                such as area or timing constraints, enumeration encoding etc.
              </div>
            </div>
          </div>

            <!-- Block Statement -->
            <div  id="Block_Statement">
            <h2>Block Statement</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Concurrent Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Architecture</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">label : block(optional_guard_condition)
  declarations
begin
  concurrent statements
end block label;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
The label is compulsory.
<pre><code class="vhdl">CONTROL_LOGIC : block
begin
  U1 : CONTROLLER_A
    port map (CLK, X, Y, Z);
  U2 : CONTROLLER_A
    port map (CLK, A, B, C);
end block CONTROL_LOGIC;

DATA_PATH : block
begin
  U3 : DATAPATH_A port map
    (BUS_A, BUS_B, BUS_C, Z);
  U4 : DATAPATH_B port map
    (BUS_A,BUS_C,BUS_D,C);
end block DATA_PATH;</code></pre>

Without a guard condition a block is a grouping together of concurrent statements within an architecture. It may have local signals, constants etc. declared.<br/><br/>

Blocks may contain further blocks, implying a form of hierarchy within a single architecture.<br/><br/>

A Block may contain any of the declarations possible for an architecture. Items declared within a block are only visible inside it.<br/><br/>

If an optional guard condition is included, the block becomes a <b>guarded block</b>. the <b>guard condition</b> must return a boolean value, and controls <b>guarded signal assignments</b> within the block. If the guard condition evaluates to false, the drive to any <b>guarded signals</b> from the block is "switched off". Such signals must be declared to be guarded signals of a resolved type. Guarded signals can be declared by adding the words <b>bus</b> or <b>register</b> after the name of the type of the signal. The difference between bus and register signals is that if all drivers to a bus signal are "switched off", it requires a resolution function to provide a value for the signal but a register signal retains its last driven value after all drivers to it have been switched off.
<pre><code class="vhdl">architecture BLKS of TRISTATE is
  signal INT: std_logic bus;
begin
  DRIVER_1 : block (EN = '1')
  begin
    INT &lt;= guarded DATA_1;
  end block DRIVER_1;
end BLKS;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Unguarded <b>block</b> statements are usually ignored by logic synthesis tools (i.e. all blocks within an architecture are "flattened").<br/><br/>
                <b>Guarded block</b> statements are <b>not</b> usually supported for synthesis.<br/><br/>
                Sequential (i.e. flip-flop and register) behaviour can be modelled using guarded blocks, but again for synthesis and readability it is better described using "clocked" processes.
              </div>
            </div>
          </div>

            <!-- Case Statement -->
            <div  id="Case_Statement">
            <h2>Case Statement</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Sequential Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Process<br>Function<br>Procedure</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">case expression is
  when choice =&gt;
    sequential statements
  when choice =&gt;
    sequential statements
end case;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
All possible choices must be included, unless the <b>others</b> clause is used as the last choice:
<pre><code class="vhdl">case SEL is
  when "01"   =&gt; Z &lt;= A;
  when "10"   =&gt; Z &lt;= B;
  when others =&gt; Z &lt;= 'X';
end case;</code></pre>

A range or a selection may be specified as a choice:
<pre><code class="vhdl">case INT_A is
  when 0      =&gt; Z &lt;= A;
  when 1 to 3 =&gt; Z &lt;= B;
  when 4|6|8  =&gt; Z &lt;= C;
  when others =&gt; Z &lt;= 'X';
end case;</code></pre>

Choices may not overlap
<pre><code class="vhdl">case INT_A is
  when 0      =&gt; Z &lt;= A;
  when 1 to 3 =&gt; Z &lt;= B;
  when 2|6|8  =&gt; Z &lt;= C;   -- illegal
  when others =&gt; Z &lt;= 'X';
end case;</code></pre>

A range may not be used with a vector type
<pre><code class="vhdl">case VEC is
  when "000" to "010" =&gt; Z &lt;= A;   -- illegal
  when "111"          =&gt; Z &lt;= B;
  when others         =&gt; Z &lt;= 'X';
end case;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
The <b>CASE</b> statement is generally synthesisable.<br/><br/>

With repeated assignments to a target signal, it willsynthesise to a large multiplexer with logic on the select inputs to evaluate the conditions for the different choices in the case statement branches. No "priority" will be inferred from the order of the branches<br/><br/>

With multiple targets and embedded <b>if</b> statements, the <b>case</b> statement may be used to synthesise a general mapping function, e.g. next state and output generation for a finite state machine. For example:
<pre><code class="vhdl">case READ_CPU_STATE is
  when WAITING =&gt;
    if CPU_DATA_VALID = '1' then
      CPU_DATA_READ  &lt;= '1';
      READ_CPU_STATE &lt;= DATA1;
    end if;
  when DATA1 =&gt;
    -- etc.
end case;</code></pre>
              </div>
            </div>
          </div>

            <!-- Component Declaration -->
            <div  id="Component_Declaration">
            <h2>Component Declaration</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Declaration</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Architecture<br>Package</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">component component_name
  generic (generic_list);
  port (port_list);
end component</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
The port list must define the name, the mode (i.e.direction) and the type of each port on the component.
<pre><code class="vhdl">component HALFADD
  port(
    A,B : in bit;
    SUM, CARRY : out bit
  );
end component;</code></pre>

A component declaration does not define the entity-architecture pair to be bound to each instance, or even the ports on the entity. These are defined by the <b>configuration</b>.<br/><br/>

In an architecture, components must be declared before the <b>begin</b> statement:
<pre><code class="vhdl">architecture STRUCTURAL of FULLADD is
  -- (local signal declarations here)
  component ORGATE
    port (
      A,B : in  bit;
      Z : out bit
    );
  end component;
  -- (other component declarations)
begin
  -- the architecture contents
end STRUCTURAL;</code></pre>

A component declared in a package is visible in any architecture which uses the package, and need not be declared again.<br/><br/>

For a component with generics, these must be declared before the ports. They do not have a mode, as by definition they can only pass information into the entity:
<pre><code class="vhdl">component PARITY
  generic (
    N : integer
  );
  port (
    A : in  std_ulogic_vector(N-1 downto 0);
    ODD : out std_ulogic
  );
end component;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                <b>Component</b> declarations are supported for synthesis, providing the port types are acceptable to the logic synthesis tool. Usually, only generics of type integer are supported. Whether a synthesis tool will "flatten through" a component, treat is as a "black box", or recognise it as a primitive is usually under the user's control.
              </div>
            </div>
          </div>

            <!-- Component Instantiation -->
            <div  id="Component_Instantiation">
            <h2>Component Instantiation</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Concurrent Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Architecture</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">instance_label : component_name
  generic map (generic_association_list)
  port map (port_association_list);</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
The instance label is compulsory. The component name must match the relevant component declaration.
<pre><code class="vhdl">architecture STRUCT of INC is
  signal X,Y,S,C : bit;
  component HALFADD
    port (
      A,B : in bit;
      SUM, CARRY : out bit
    );
  end component;
begin
  U1: HALFADD
    port map (X,Y,S,C);
    -- other statements
end STRUCT;</code></pre>

The association list defines which local signals connect to which component ports. The association list above is <b>positional</b>, i.e. the signals are connected up in the order in which the ports were declared.<br/><br/>

The alternative is <b>named association</b>, where ports are explicitly referenced and order is not important:
<pre><code class="vhdl">ADDER1 : HALFADD
  port map (
    B     =&gt; Y,
    A     =&gt; X,
    SUM   =&gt; S,
    CARRY =&gt; C);</code></pre>

Ports may be left unconnected using the keyword <b>open</b>:
<pre><code class="vhdl">ADDER2 : HALFADD
  port map (
    B     =&gt; Y,
    A     =&gt; X,
    SUM   =&gt; S,
    CARRY =&gt; open);</code></pre>

An instance of a component with generics, has a <b>generic map</b> declared before the port map:
<pre><code class="vhdl">U1 : PARITY
  generic map (
    N =&gt; 8)
  port map (
    A   =&gt; DATA_BYTE,
    ODD =&gt; PARITY_BYTE);</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Component instantiation is supported for synthesis, although <b>generic map</b> is usually ignored. Whether a logic synthesis tool will "flatten through" a component, treat it as a "black box", or recognise it as a primitive is usually under the user's control.
              </div>
            </div>
          </div>

            <!-- Configuration Specification -->
            <div  id="Configuration_Specification">
            <h2>Configuration Specification</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Specification</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Architecture</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">for instance_label : component_name
  use entity
    library_name.entity_name(architecture_name);</code></pre>
<pre><code class="vhdl">for instance_label : component_name
  use configuration library_name.config_name;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
Using a configuration <b>specification</b>, components may be configured within an architecture which instances them, rather than using a separate configuration declaration design unit. This is less flexible, as the architecture has to be re-analysed to change the configuration.<br/><br/>

Component instances may be individually configured:
<pre><code class="vhdl">architecture STR of XA is
  component HALFADD
    port (
      A,B : in bit;
      SUM, CARRY : out bit);
  end component;
  component ORGATE
    port (
      A,B : in bit;
      Z : out bit);
  end component;

  for U1 : HALFADD use entity
    work.HA(BEHAVE);
  for U2 : ORGATE use entity
    work.OG(BEHAVE);
begin
  U1 : HALFADD port map (A,B,S,C);
  U2: ORGATE port map (A,B,Y);
end STR;</code></pre>

The keyword <b>all</b> may be used to refer to all instances of a component:
<pre><code class="vhdl">for all : FULLADDER use entity
  work.FULLADD(STRUCTURAL);</code></pre>

The keyword <b>others</b> may also be used to refer to all instances not explicitly mentioned.<br/><br/>

If the port names on an entity do not match those on the component declaration, a port map may be included in the configuration:
<pre><code class="vhdl">for all : HALFADD use entity
  work.HALFADD(BEHAVE)
  port map (
    X =&gt; A,
    Y =&gt; B,
    S =&gt; SUM,
    C =&gt; CARRY);</code></pre>

In the abscence of an explicit configuration for any part of a model, <b>default binding</b> will occur. For each unbound instance of every component, an entity will be selected whose name, port names and port types etc. match thosein the corresponding component declaration. Where an entity has more than one architecture, the <b>last analysed</b> architecture will be used.
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Configuration is not usually supported by synthesis tools. The user usually has to ensure that component and entity names and ports match, and that only one architecture per entity is analysed.
              </div>
            </div>
          </div>

            <!-- Constant Declaration -->
            <div  id="Constant_Declaration">
            <h2>Constant Declaration</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Declaration</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Entity<br>Package<br>Process<br>Architecture<br>Procedure<br>Function</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">constant constant_name : type := value;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">constant BUS_WIDTH : integer := 8;
constant FOUR_ONES : std_logic_vector(3 downto 0) := "1111";
constant PERIOD : time := 10 ns;
constant MAX_SIM_TIME : time:= 50 * PERIOD;</code></pre>

The values of array constants of types other than stribg, bit_vector and std_logic_vector, must be set using aggregates.
<pre><code class="vhdl">type T_CLOCK_TIME is ARRAY(3 downto 0) of integer range 0 to 9;
constant TWELVE_O_CLOCK : T_CLOCK_TIME := (1,2,0,0);</code></pre>

In a package, a constant may be <b>deferred</b>. This means its value is defined in the package body. the value may be changed by re-analysing only the package body.
<pre><code class="vhdl">package P is
  constant C : integer;
end P;

package body P is
  constant C : integer := 200;
end P;</code></pre>

Provided they are of the correct type, constants may be used in any expression. They may be associated with generics of component instances and passed into procedures.
<pre><code class="vhdl">process
  type T_DATA is array (0 to 3) of bit_vector(7 downto 0);
  constant DATA : T_DATA := (
    "00001000",
    "00010001",
    "00100010",
    "01000011");
begin
  for I in DATA'range loop
    serialize_byte(DATA(I), DOUT);
  end loop;
end process;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Constants are supported for synthesis, providing they are of a type acceptable to the logic synthesis tool. They are either synthesised as connections to logic '1' or '0', or are used to help minimise the number of gatyes required. Deferred constants may not bwe supported.
              </div>
            </div>
          </div>

            <!-- Entity -->
            <div  id="Entity">
            <h2>Entity</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Primary Library Unit</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">entity entity_name is
  generic (generic_list);
  port (port_list);
end entity_name;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
The port list must define the name, the mode (i.e. direction) and the type of each port on the <b>entity</b>:
<pre><code class="vhdl">entity HALFADD is
  port (
    A,B : in bit;
    SUM, CARRY : out bit
  );
end HALFADD;</code></pre>

<pre><code class="vhdl">entity COUNTER is
  port (
    CLK   : in  std_ulogic;
    RESET : in  std_ulogic;
    Q     : out integer range 0 to 15
  );
end COUNTER;</code></pre>

The top-level <b>entity</b> in a simulateable <b>VHDL</b> model is usually "empty", i.e. has no ports. Its architecture is usually the "test bench":
<pre><code class="vhdl">entity TB_DISPLAY is
end TB_DISPLAY;

architecture TEST of TB_DISPLAY is
-- signal declarations
-- component declaration(s)
begin
-- component instance(s)
-- test processes
end TEST;</code></pre>

Each <b>entity</b> port acts like a signal which is visible in the architecture(s) of the <b>entity</b>. The mode (i.e.direction) of each port determines whether it may be read from or written to in the architecture:
<table class="table table-bordered">
  <tbody>
    <tr>
      <th>Mode</th> <th>Read in Arch?</th> <th>Write in Arch</th>
    </tr>
    <tr>
      <td>in</td> <td>Yes</td> <td>No</td>
    </tr>
    <tr>
      <td>out</td> <td>No</td> <td>Yes</td>
    </tr>
    <tr>
      <td>inout</td> <td>Yes</td> <td>Yes</td>
    </tr>
    <tr>
      <td>buffer</td> <td>Yes</td> <td>Yes</td>
    </tr>
  </tbody>
</table>

If an <b>entity</b> has generics, these must be declared before the ports. They do not have a mode, as by definition they can only pass information into the <b>entity</b>:
<pre><code class="vhdl">entity AN2_GENERIC is
  generic (
    DELAY: time := 1.0 ns
  );
  port (
    A,B : in std_ulogic;
    Z : out std_ulogic
  );
end AN2_GENERIC;</code></pre>

An <b>entity</b> may also contain declarations. Items declared are visible within the arhitecture(s) of the <b>entity</b>.
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Entity declarations are supported for suynthesis, providing the port types are acceptable to the logic synthesis tool. Usually, only generics of type integer are supported. Values for generics have to be supplied by the user at the time of synthesis.
              </div>
            </div>
          </div>

            <!-- Exit Statement -->
            <div  id="Exit_Statement">
            <h2>Exit Statement</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Sequential Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Loop<br>For Loop<br>While Loop</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">exit;</code></pre>
                <pre><code class="vhdl">exit loop_label;</code></pre>
                <pre><code class="vhdl">exit loop_label when condition;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
The exit statement is used to terminate a <b>while, for</b> or infinite <b>loop</b>:
<pre><code class="vhdl">for I in 0 to 7 loop
  if FINISH_LOOP_EARLY = '1' then
    exit;
  else
    A_BUS &lt;= TABLE(I);
    wait for 5 ns;
  end if;
end loop;</code></pre>

The exit statement may test a boolean condition directly using the <b>when</b> keyword.
<pre><code class="vhdl">process(A)
  variable I : integer range 0 to 4;
begin
  Z &lt;= "0000";
  I := 0;
  loop exit when I = 4;
    if (A = I) then
      Z(I) &lt;= '1';
    end if;
    I := I + 1;
  end loop;
end process;</code></pre>

For an exit statement within a set of nested loops, the optional loop label may be used to indicate which level of loop is to be exited. The default (no label) is the innermost loop:
<pre><code class="vhdl">L1 : for I in 0 to 7 loop
  L2: for J in 0 to 7 loop
    exit L1 when QUIT_BOTH_LOOPS = '1';
    exit when QUIT_INNER_LOOP = '1';
    -- other statements
  end loop L2;
end loop L1;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                The exit statement is supported by some logic synthesis tools, with certain restrictions.
              </div>
            </div>
          </div>

            <!-- File Declaration -->
            <div  id="File_Declaration">
            <h2>File Declaration</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Declaration</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Package<br>Process<br>Architecture<br>Procedure<br>Function</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">file logical_name : file_type is mode "file_name";</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
Usually, files of type <b>text</b> are used as they are portable between different VHDL simulators. The <b>mode</b> of the <b>file</b> refers to the direction of data flow, and may be either <b>in</b> (i.e. a
read-only <b>file</b>) or <b>out</b> (a write-only <b>file</b>):
<pre><code class="vhdl">use std.textio.all;
package REF_PACK is
  file INFILE  : text is in  "in.dat";
  file OUTFILE : text is out "out.dat";
end REF_PACK;</code></pre>

Text files may be read by using the <b>endfile, readline</b> and <b>read</b> subprograms defined in the package <b>std.textio</b>:
<pre><code class="vhdl">READ_FILE : process
  variable VEC_LINE : line;
  variable VEC_VAR : bit_vector(0 to 7);
  file VEC_FILE : text is in "stim.vec";
begin
  while not endfile(VEC_FILE) loop
    readline (VEC_FILE, VEC_LINE);
    read (VEC_LINE, VEC_VAR);
    A_BUS &lt;= VEC_VAR;
    wait for 10 ns;
  end loop;
  wait;
end process READ_FILE;</code></pre>

The textio package <b>must</b> be made visible by the clause:
<pre><code class="vhdl">use std.textio.all;</code></pre>

Text files may be written by using the <b>write</b> and <b>writeln</b> subprograms, also defined in the textio package. Output data may be formatted using optional parameters for <b>write</b>.<br/><br/>

Textio <b>read</b> and <b>write</b> procedures are defined for the types <b>bit, bit_vector, bolean, character, integer, real, string</b> and <b>time</b>. They are <b>not</b> compatible with user-defined types or std_logic_1164 types (although some vendors supply routines for the std_logic_1164_types).<br/><br/>

Text files may be written by using the <b>writeln</b> and <b>write</b> subprograms defined in the package <b>std.textio</b>
<pre><code class="vhdl">WRITE_FILE : process (CLK)
  variable VEC_LINE : line;
  file VEC_FILE : text is out "results";
begin
  -- strobe OUT_DATA on falling edges
  -- of CLK and write value out to file
  if CLK='0' then
    write (VEC_LINE, OUT_DATA);
    writeline (VEC_FILE, VEC_LINE);
  end if;
end process WRITE_FILE;</code></pre>

A <b>file</b> (read or write) is opened in VHDL when the structure in which it is declared is elaborated. This means that files declared in processes or architectures are opened only once at the beginning of a simulation. files declared in procedures are reopened at the beginning of the <b>file</b> every time the procedure is elaborated (every time it is executed) and are closed every time the procedure finishes execution.
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                File declarations and operations are not supported by logic synthesis tools.
              </div>
            </div>
          </div>

            <!-- For Loop -->
            <div  id="For_Loop">
            <h2>For Loop</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Sequential Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Process<br>Function<br>Procedure</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">optional_label : for parameter in range loop
  sequential statements
end loop label;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
The <b>for</b> loop defines a loop parameter which takes on the type of the range specified. For example, the range <b>0 to 3</b> implies an integer:
<pre><code class="vhdl">process (A)
begin
  Z &lt;= "0000";
  for I in o to 3 loop
    if (A = I) then
      Z(I) &lt;= '1';
    end if;
  end loop;
end process;</code></pre>

Attributes such as <b>'high, 'low</b> and <b>'range</b> may also be used to define the iterations of a <b>for</b> loop:
<pre><code class="vhdl">process (A)#
  variable TMP : std_ulogic;
begin
  TMP := '0';
  for I in A'low to A'high loop
    TMP := TMP xor A(I);
  end loop;
  ODD &lt;= TMP;
end process;</code></pre>

The range may be any discrete range, e.g. an enumerated type:
<pre><code class="vhdl">type PRIMARY is (RED, GREEN, BLUE);
type COLOUR is ARRAY (PRIMARY) of integer range 0 to 255;
-- other statements
MUX: process
begin
  for SEL in PRIMARY loop
    V_BUS &lt;= VIDEO(SEL);
    wait for 10 ns;
  end loop;
end process MUX;</code></pre>

The loop parameter does not need to be declared: it is implicitly declared within the loop. It may not be modified within the loop:
<pre><code class="vhdl">for I in 1 to 10 loop
  if (REPEAT = '1') then
    I := I-1;	-- Illegal
  end if;
end loop;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                The for loop is supported for synthesis, providing:
                <ol>
                  <li>the loop range is static (i.e. implies a definite number of iterations), and</li>
                  <li>the loop contains no <b>wait</b> statements.</li>
                </ol>
              </div>
            </div>
          </div>

            <!-- Functions -->
            <div  id="Functions">
            <h2>Functions</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Declaration</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Package<br>Entity<br>Architecture<br>Process<br>Procedure<br>Function</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">function function_name (parameter_list) return type is
  declarations
begin
  sequential statements
end function_name;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
A function can only have input parameters, so the mode (direction) is not specified.
<pre><code class="vhdl">function BOOL_TO_SL(X : boolean) return std_ulogic is
begin
  if X then
    return '1';
  else
    return '0';
  end if;
end BOOL_TO_SL;</code></pre>

A function may declare local variables. These do not retain their values between successive calls, but are re-initialised each time. Array-type parameters may be unconstrained:
<pre><code class="vhdl">function PARITY (X : std_ulogic_vector) return std_ulogic is
  variable TMP : std_ulogic := '0';
begin
  for J in X'range loop
    TMP := TMP xor X(J);
  end loop; -- works for any size X
  return TMP;
end PARITY;</code></pre>

A function may contain any sequential statement except <b>signal assignment</b> and <b>wait</b>. A type-conversion function may be called in a port map, to match port type to signal type.<br/><br/>

If a function is defined in a package, its body (the algorithm part) must be placed in the package body:
<pre><code class="vhdl">package REF_PACK is function PARITY (X : bit_vector) return bit;
end REF_PACK;

package body REF_PACK is
  function PARITY (X : bit_vector) return bit is
  begin
    -- function code
  end PARITY;
end REF_PACK;</code></pre>

A function is called as an expression, in either a concurrent or sequential statement:
<pre><code class="vhdl">architecture FUNCTIONS of PAR is
begin
  PARITY_BYTE &lt;= PARITY(DATA_BYTE);
  PARITY_WORD &lt;= PARITY(DATA_WORD);
end FUNCTIONS;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                User-defined functions are usually supported for synthesis, providing they act on suitable data types. Different synthesis tools recognise various different type conversion and resolution functions. Most accept those deined in the std_logic_1164 package.
              </div>
            </div>
          </div>

            <!-- Generate Statement -->
            <div  id="Generate_Statement">
            <h2>Generate Statement</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Concurrent Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Architecture</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">label: for parameter in range generate
  concurrent statements
end generate label;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
The for .. generate statement is usually used to instantiate "arrays" of components. The generate parameter may be used to index array-type signals associated with component ports:
<pre><code class="vhdl">architecture GEN of REG_BANK is
  component REG
    port (
      D, CLK, RESET : in  std_ulogic;
      Q             : out std_ulogic
    );
  end component;
begin
  GEN_REG : for I in 0 to 3 generate
    REGX : REG port map (DIN(I), CLK, RESET, DOUT(I));
  end generate GEN_REG;
end GEN;</code></pre>

A label is compulsory with a generate statement.<br/><br/>

The for .. generate statement is particularily powerful when used with integer generics.<br/><br/>

Instance labels inside a generate statement do not need to have an index:
<pre><code class="vhdl">REGX(I) :	-- Illegal</code></pre>

The for .. generate statements may be nested to create two-dimensional instance "arrays".<br/><br/>

Another form of generate is the if .. generate statement. This is usually used within a for .. generate
statement, to account for irregularity. For instance, a ripple-carry adder with no carry-in:
<pre><code class="vhdl">architecture GEN of RIPPLE is
  component FULLADD
    port (
      A, B, CIN  : in  bit;
      SUM, CARRY : out bit
    );
  end component;

  component HALFADD
    port (
      A, B       : in bit;
      SUM, CARRY : out bit
    );
  end component;

  signal C : bit_vector(0 to 7);

begin

  GEN_ADD: for I in 0 to 7 generate

    LOWER_BIT: if I=0 generate
      U0: HALFADD port map (A(I), B(I), S(I), C(I));
    end generate LOWER_BIT;

    UPPER_BITS: if I&gt;0 generate
      UX: FULLADD port map (A(I), B(I), C(I-1), S(I), C(I));
    end generate UPPER_BITS;

  end generate GEN_ADD;

  COUT &lt;= C(7);

end GEN;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Generate statements are usually supported for synthesis.
              </div>
            </div>
          </div>

            <!-- Generics -->
            <div  id="Generics">
            <h2>Generics</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Declaration</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Entity<br>Component</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">entity entity_name is
  generic (generic list);
  port    (port list);
end entity_name;</code></pre><br/>

<pre><code class="vhdl">component component_name
  generic (generic_list);
  port    (port_list);
end component;</code></pre><br/>

<pre><code class="vhdl">instance_label: component_name
  generic map (generic_association_list)
  port map    (port_association_list);</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
Generics are a means of passing specific information into an entity. They do not have a mode (direction):
<pre><code class="vhdl">entity PARITY is
  generic (
    N : integer
  );
  port (
    A   : in  std_ulogic_vector(N-1 downto 0);
    ODD : out std_ulogic
  );
end PARITY;</code></pre>

In the corresponding component declaration, the generics are also declared before the ports:
<pre><code class="vhdl">component PARITY
  generic (
    N : integer
  );
  port (
    A   : in  std_ulogic_vector(N-1 downto 0);
    ODD : out std_ulogic
  );
end component;</code></pre>

An instance of a component with generics, has a generic map declared before the port map (note: there is no semicolon between them!). This allows a value to be set for the generic:
<pre><code class="vhdl">U1 : PARITY
  generic map (
    N =&gt; 8
  )
  port map (
    A   =&gt; DATA_BYTE,
    ODD =&gt; PARITY_BYTE
  );</code></pre>

By declaring generics of type time, delays may be programmed on an instance-by-instance basis. Generics may be given a default value, in case a value is not supplied for all instances:
<pre><code class="vhdl">entity AN2_GENERIC is
  generic (
    DELAY: time := 1.0 ns
  );
  port (
    A, B : in std_ulogic;
    Z    : out std_ulogic
  );
end AN2_GENERIC;

architecture BEH of AN2_GENERIC is
begin
  Z &lt;= A and B after DELAY;
end A;</code></pre>

The value of a generic may be read in either the entity or any of its architectures. It may even be passed into lower-level components.<br/><br/>

Default values for generics may be given in an entity declaration or in a component declaration. Generics may be set (via a generic map) in an instantiation, or a configuration. The rules regarding different combinations of these are complex.
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Usually, only generics of type integer are supported. Values for generics in an entity declaration have to be supplied by the user to allow elaboration at the time of synthesis. generic map is usually ignored.
              </div>
            </div>
          </div>

            <!-- If Statement -->
            <div  id="If_Statement">
            <h2>If Statement</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Sequential Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Process<br>Function<br>Procedure</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">if condition_1 then
  sequential statements
elsif condition2 then
  sequential statements
else
  sequential statements
end if;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
Conditions may overlap - <b>only</b> the statements after the <b>first</b> "true" condition are executed.
<pre><code class="vhdl">if (X = 5) and (Y = 9) then
  Z &lt;= A;
elsif (X &gt;= 5) then
  Z &lt;= B;
else
  Z &lt; C;
end if;</code></pre>

The <b>elsif</b> and <b>else</b> clauses are optional. This process models a transparent latch:
<pre><code class="vhdl">process (EN, D)
begin
  if (EN = '1') then
    Q &lt;= D;
  end if;
end process;</code></pre>

A condition is any boolean expression:
<pre><code class="vhdl">process (ALARM_TIME, CURRENT_TIME)
  variable AL_EQ_CUR: boolean;
begin
  AL_EQ_CUR := (ALARM_TIME = CURRENT_TIME);
  if AL_EQ_CUR then
    SOUND_ALARM &lt;= '1';
  else
    SOUND_ALARM &lt;= '0';
  end if;
end process;</code></pre>

An <b>if</b> statement may be used to infer edge-triggered registers in a process sensitive to a clock signal. Asynchronous reset may also be modeled:
<pre><code class="vhdl">process(CLK, RESET)
begin
  if RESET = '1' then
    COUNT &lt;= 0;
  elseif CLK'event and CLK='1' then
    if (COUNT &gt;= 9) then
      COUNT &lt;= 0;
    else
      COUNT &lt;= COUNT + 1;
    end if;
  end if
end process;</code></pre>

<b>If</b> statements may be used to specify conditional assignments or state transitions in a finite state machine:
<pre><code class="vhdl">case READ_CPU_STATE is
  when WAITING =&gt;
    if CPU_DATA_VALID = '1' then
      CPU_DATA_READ &lt;= '1';
      READ_CPU_STATE &lt;= DATA1;
    end if;
  when DATA1 =&gt;
  -- other branches of the case statement
end case;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                The <b>if</b> statement is generally synthesisable. Where an <b>if</b> statement is used to detect the clock edge in a "clocked process", certain conventions must be obeyed. Using an <b>if</b> statement without an <b>else</b> clause in a "combinational process" can result in latches being inferred, unless all signals driven by the process are given unconditional default assignments. For more details see Process.
              </div>
            </div>
          </div>

            <!-- Literals -->
            <div  id="Literals">
            <h2>Literals</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Literal</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Expression</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">Numeric Value</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
Numeric literals with a decimal point are real, those without are integer;
<pre><code class="vhdl">constant FREEZE : integer := 32;
constant TEMP : real := 32.0;</code></pre>

Numeric literasls may be expressed in any base from 2 to 16. They may also be broken up using underscore, for clarity.
<pre><code class="vhdl">A_INT &lt;= 16#FF#;
B_INT &lt;= 2#1010_1010#;
MONEY := 1_000_000.0;</code></pre>

Numeric literasls may be expressed in any base from 2 to 16. They may also be broken up using underscore, for clarity.
<pre><code class="vhdl">A_INT &lt;= 16#FF#;
B_INT &lt;= 2#1010_1010#;
MONEY := 1_000_000.0;</code></pre>

Real numbers may be expressed in exponential form:
<pre><code class="vhdl">FACTOR := 2.2E-6;</code></pre>

Literals of type time (and other physical types) must have units. The units should be preceded by a space, although some tools may not require this:
<pre><code class="vhdl">constant DEL1 :time := 10 ns;
constant DEL2 :time := 2.27 us;</code></pre>

Literals of enumerated types may either be characters (as for bit and std_logic), or identifiers:
<pre><code class="vhdl">type MY_LOGIC is ('X','0','1','Z');
type T_STATE is (IDLE, READ, END_CYC);
signal CLK : MY_LOGIC := '0';
signal STATE : T_STATE := IDLE;</code></pre>

Literals for arrays of characters, such as string, bit_vector and std_logic_vector are placed in double quotes:
<pre><code class="vhdl">constant FLAG :bit_vector(0 to 7) := "11111111";
constant MSG : string := "Hello";</code></pre>

Bit vector literals may be expressed in binary (the default), opctal or hex. They may also contain embedded underscores for clarity. These forms may <b>not</b> be used as std_logic_vector literals:
<pre><code class="vhdl">BIT_8_BUS &lt;= B"1111_1111";
BIT_9_BUS &lt;= O"353";
BIT_16_BUS &lt;= X"AA55";</code></pre>

For how to define other array literals and record literals, see arrays and aggregrates.<br/><br/>

Non-printing characters may be included in a string literal using concatenation:
<pre><code class="vhdl">constant TWO_LINE_MSG : string := "Hello" &amp; CR &amp; "World";</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Literals are supported for synthesis, providing they are of a type acceptable to the logic synthesis tool. They are either synthesised as connections to logic '1' or '0', or are used to help minimised the number of gates required.
              </div>
            </div>
          </div>

            <!-- Names -->
            <div  id="Names">
            <h2>Names</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Identifier</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Entity<br>Architecture<br>Package<br>Package Body<br>Configuration</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">Name</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
Names (or identifiers) may consist of letters, numbers and underscore:
<pre><code class="vhdl">architecture RTL of UNIT_34 is
signal SOUND_ALARM : std_ulogic;</code></pre>

Case is not significant, so the following are all equivalent:
<pre><code class="vhdl">An_Example_Name
AN_EXAMPLE_NAME
an_example_name</code></pre>

Names must start with a letter:
<pre><code class="vhdl">signal 16_BIT_BUS : integer;   -- illegal
signal _BUS_16_BIT_ : integer; -- illegal
signal BUS_16_BIT : integer;   -- OK</code></pre>

Names may be of arbitary length.<br/><br/>

None of the VHDL keywords (i.e. signal, bus, component, wait, etc.) may be reused as a name.
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Legal names (identifiers) are supported for synthesis, but long names may be truncated in some tools, or when using certain output netlist formats.
              </div>
            </div>
          </div>

            <!-- Next Statement -->
            <div  id="Next_Statement">
            <h2>Next Statement</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Sequential Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Loop<br>For Loop<br>While Loop</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">next;</code></pre>
                <pre><code class="vhdl">next loop_label;</code></pre>
                <pre><code class="vhdl">next loop_label when condition;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
The next statement is used to prematurely terminate the current iteration of a while, for, or infinite loop:
<pre><code class="vhdl">for I in 0 to 7 loop
  if SKIP = '1' then
    next;
  else
    N_BUS &lt;= TABLE(I);
    wait for 5 ns;
  end if;
end loop;</code></pre>

The next statement may test a boolean condition directly, using the when keyword:
<pre><code class="vhdl">process (A)
begin
  Z &lt;= "0000";
  for I in 0 to 3 loop
    next when A /= I;
    Z(I) &lt;= '1';
  end loop;
end process;</code></pre>

For a next statement within a set of nested loops, the optional loop label may be used to indicate which level of loop is to be iterated. The default (no label) is the innermost loop. If an outer loop is specified, loops inside are effectively exited:
<pre><code class="vhdl">READ_BUS: process
begin
  RESETLOOP: loop
    VALID_CHECK: while (CPU_DATA_VALID /= '1') loop
      wait until rising_edge(CLK) or RESET = '1';
      next RESETLOOP when RESET='1';
    end loop VALID_CHECK;
    CPU_DATA_READ &lt;= '1';
    wait until rising_edge(CLK);
    LOCAL_BUFFER &lt;= DATA_BUS;
    wait until rising_edge(CLK);
    CPU_DATA_READ &lt;= '0';
  end loop RESETLOOP;
end process READ_BUS;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                The next statement is supported by some logic synthesis tools, with certain restrictions.
              </div>
            </div>
          </div>

            <!-- Null Statement -->
            <div  id="Null_Statement">
            <h2>Null Statement</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Sequential Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Process<br>Function<br>Procedure</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">null;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
The null statement performs no action. It is usualls used with the case statement, to indicate that under certain conditions, no action is required.
<pre><code class="vhdl">case ENCRYPTION is
  when "00" =&gt;
    CPU_DATA_TMP := (B &amp; A) - OPERAND;
  when "01" =&gt;
    CPU_DATA_TMP := (B &amp; A) + OPERAND;
  when "10" =&gt;
    CPU_DATA_TMP := (A &amp; B) - OPERAND;
  when "11" =&gt;
    CPU_DATA_TMP := (A &amp; B) + OPERAND;
  when others =&gt;
    null;
end case;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                The null statement is supported by synthesis tools.<br/><br/>

                Note: using a null statement in a "combinational process" can result in latches being inferred, unless all signals driven by the process are given unconditional default assignments.
              </div>
            </div>
          </div>

            <!-- Operators -->
            <div  id="Operators">
            <h2>Operators</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Operator</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Expression</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">and, or, nand, nor, xor, not, =, /=, &gt;, &lt;, &gt;=, &lt;=, &amp;, +, -, *, /</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
The logical operators are predefined for bit, boolean, bit_vector, linear arrays of boolean, std_logic and std_logic_vector types. They return a value of the same type:
<pre><code class="vhdl">and, or, nand, nor, xor, not</code></pre>

The <b>equality</b> and <b>inequality</b> operators are predefined for all types, and they return a boolean value:
<pre><code class="vhdl">=   -- equal to
/=  -- not equal to</code></pre>

The other relational operators are predefined for all scalar types, and all one-dimensional array types. They also return a boolean value:
<pre><code class="vhdl">&lt;   -- less than
&gt;   -- greater than
&lt;=  -- less than or equal to
&gt;=  -- greater than or equal to</code></pre>

For arrays of different lengthsm the predefined relational operators align the left-hand elements and compare corresponding positions. This can lead to unexpected results:
<pre><code class="vhdl">constant ARR1 :bit_vector := "0011";
constant ARR2 :bit_vector := "01";
-- (ARR1 &lt; ARR2) will return true</code></pre>

The <b>&amp;</b> operator is used to concatenate (join) arrays, or join new elements to an array:
<pre><code class="vhdl">Z_BUS(1 downto 0) &lt;= '0' &amp; B_BIT;
BYTE &lt;= A_BUS &amp; B_BUS;</code></pre>

Add, subtract, multiply and divide are defined for integer and real. Both operands must be the same type, and the result is also of the same type:
<pre><code class="vhdl">signal INT1, INT2: integer := 0;
signal REAL1, REAL2: real := 6.7;
...
INT1  &lt;= INT1 + 3;
REAL1 &lt;= REAL2 - 2.2;
INT2  &lt;= INT1 * REAL1;   --illegal
INT2  &lt;= INT1 * INTEGER(REAL1);
REAL2 &lt;= REAL1 / 42.3;</code></pre>

For physical types (e.g.time), assignments must be dimensionally consistant:
<pre><code class="vhdl">variable TIME1,TIME2: time;
...
TIME1 := TIME2 * 2.5;
TIME1 := TIME2 / 4;
TIME1 := 3.6 ns + TIME2;
TIME1 := TIME2 * 6.67 ns;   --illegal</code></pre>

Other numeric operators are exponentiation (<b>**</b>), absolute value (<b>abs</b>), modulus (<b>mod</b>), and remainder (<b>rem</b>).
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Most predefined operators are synthesisable, providing they are used with types accepted by the synthesis tool. See also type declarations and overloading.<br/><br/>

                The following are <b>not</b> usually synthesisable, except as part of a constant expression: exponentiation (**), division by other than 2, mod, rem.
              </div>
            </div>
          </div>

            <!-- Package -->
            <div  id="Package">
            <h2>Package</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Primary Library Unit</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">package package_name is
	declarations
end package_name;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
Declarations may typically be any of the following: type, subtype, constant, file, alias, component, attribute, function, procedure.
<pre><code class="vhdl">package DEMO_PACK is
  constant SOME_FLAG : bit_vector := "11111111";
  type STATE is (RESET,IDLE,ACKA);
  component HALFADD
    port (
      A, B       : in bit;
      SUM, CARRY : out bit);
  end component;
end DEMO_PACK;</code></pre>

Items declared in a package are visible wherever selected via a use clause. For instance, assume DEMO_PACK is analysed into library work:
<pre><code class="vhdl">use work.DEMO_PACK.all;

entity DEMO is
  port (
    Z: out bit_vector(7 downto 0)
  );
end DEMO;

architecture BEHAVE of DEMO is
begin
  Z &lt;= SOME_FLAG;
end BEHAVE;</code></pre>

When a procedure or function is declared in a package, its body (the algorithm part) must be placed in the package body.

A constant declared in a package may be <b>deferred</b>. This means that its value may be changed by re-analysing omly the package body:
<pre><code class="vhdl">package P is
  constant C : integer;
end P;

package body P is
  constant C : integer := 200;
end P;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Packages are usually supported by synthesis tools, provided all the items they declare are compatible with synthesis.<br/><br/>

                Synthesisable declarations and non-synthesisable declarations (e.g.for a test bench) should therefore be placed in separated packages.<br/><br/>

                Design Libraries are often not supported, so design files containing packages must either by analysed first for synthesis, or be present in the local directory.<br/><br/>

                If a package has a body, it must usually be in the same design file as the package itself.
              </div>
            </div>
          </div>

            <!-- Package Body -->
            <div  id="Package_Body">
            <h2>Package Body</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Secondary Library Unit</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">package body package_name is
  declarations
  deferred constant declarations
  subprogram bodies
end package_name;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
When a procedure or function is declared in a package, its body (the algorithm part) must be placed in the package body:
<pre><code class="vhdl">package REF_PACK is
  procedure PARITY (
    signal X : in bit_vector;
    signal Y : out bit
  );
end REF_PACK;

package body REF_PACK is
  procedure PARITY (
    signal X : in bit_vector;
    signal Y : out bit) is
  begin
    -- procedure code
  end PARITY;
end REF_PACK;</code></pre>

Other declarations made in a package body may be used within that body, but are <b>not</b> visible outside. declarations may typically be any of the following: type, subtype, constant, file, alias, attribute, function, procedure.<br/><br/>

A constant declared in a package may be deferred. This means its value is defined in the package body. The value may be changed by re-analysing only the package body:
<pre><code class="vhdl">package P is
  constant C : integer;
end P;

package body P is
  constant C : integer := 200;
end P;</code></pre>

A package body cannot be analysed unless a matching package exists
in the same design library.<br/><br/>

Each package can only have one <b>body</b>.
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Package bodies are usually supported by synthesis tools, provided all the items they declare are compatible with synthesis.
                <br/><br/>
                A package body must usually be in the same design file as the package itself.
              </div>
            </div>
          </div>

            <!-- Procedures -->
            <div  id="Procedures">
            <h2>Procedures</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Declaration</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Package<br>Entity<br>Architecture<br>Process<br>Procedure<br>Function</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">procedure procedure_name (parameter_list) is
  declarations
begin
  sequential statements
end procedure_name;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
Procedures may have in, out or inout parameters. These may be signal, variable or constant. the default for in parameters is constant. For out and inout it is variable. In fact, a constant in parameter can be associated with a signal, variable constant or expression when the procedure is called:
<pre><code class="vhdl">procedure DISPLAY_MUX
  (
    ALARM_TIME, CURRENT_TIME : in digit;
    SHOW_A                   : in std_ulogic;
    signal DISPLAY_TIME      : out digit
  ) is
begin
  if (SHOW_A = '1') then
    DISPLAY_TIME &lt;= ALARM_TIME;
  else
    DISPLAY_TIME &lt;= CURRENT_TIME;
  end if;
end DISPLAY_MUX;</code></pre>

Procedures may be called concurrently or sequentially. A concurrent procedure call executes whenever any of its in or inout parameters change:
<pre><code class="vhdl">architecture SUBPROG of DISP_MUX is
  ...
begin
  DISPLAY_MUX (ALARM_TIME, CURRENT_TIME, SHOW_A, DISPLAY_TIME);
end SUBPROG;</code></pre>

A procedure may declare local variables. These do not retain their values between successive calls, but are re-initialised each time. Array-type parameters may be unconstrained.
<pre><code class="vhdl">procedure PARITY
  (
    signal X : in std_ulogic_vector;
    signal Y : out std_ulogic
  ) is
  variable TMP : std_ulogic := '0';
begin
  for J in X'range loop
    TMP := TMP xor X(J);
  end loop; -- works for any size X
  Y &lt;= TMP;
end PARITY;</code></pre>

A procedure can contain wait statements, unless it is called from a process with a sensitivity list, or from within a function.<br/><br/>

If a procedure is defined in a package, its body (the algorithm part) must be placed in the package body.
<pre><code class="vhdl">package REF_PACK is
  procedure PARITY
    (
      signal X : in std_logic_vector;
      signal Y : out std_logic
    );
end REF_PACK;

package body REF_PACK is
  procedure PARITY
    (
      signal X : in std_logic_vector;
      signal Y : out std_logic
    ) is
  begin
    -- procedure code
  end PARITY;
end REF_PACK;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Procedures are usually supported for synthesis, providing they do not contain any wait statements.
              </div>
            </div>
          </div>

            <!-- Process -->
            <div  id="Process">
            <h2>Process</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Concurrent Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Architecture</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">optional_label : process(optional sensitivity list)
  declarations
begin
  sequential statements
end process optional_label;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
The <b>sensitivity list</b> is a list of signals. A change in value on one or more of these signals, causes the process to be activated:
<pre><code class="vhdl">process(ALARM_TIME, CURRENT_TIME)
begin
  if (ALARM_TIME = CURRENT_TIME) then
    SOUND_ALARM &lt;= '1';
  else
    SOUND_ALARM &lt;= '0';
  end if;
end process;</code></pre>

Alternatively, process activation and suspension may be controlled via the wait statement:
<pre><code class="vhdl">process
begin
  if (ALARM_TIME = CURRENT_TIME) then
    SOUND_ALARM &lt;= '1';
  else
    SOUND_ALARM &lt;= '0';
  end if;
  wait on ALARM_TIME, CURRENT_TIME;
end process;</code></pre>

<b>NOTE:</b> A process cannot have both a sensitivity list and wait statements.<br/><br/>

A process may contain any sequential statement.
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
Processes are synthesisable, provided they match certain typical forms, some of which are shown below:<br/><br/>

A "clocked process" with either a wait statement or sensitivity list. For such a process, registers are inferred on <b>all</b> signals which have assignments to them:
<pre><code class="vhdl">WAIT_PROC: process
begin
  wait until CLK'event and CLK='1';
  Q1 &lt;= D1;
end process;

SENSE_PROC: process(CLK)
begin
  if CLK'event and CLK='1' then
    Q2 &lt;= D2;
  end if;
end process;</code></pre>

A "combinational process" must have a sensitivity list containing all the signals which it reads (inputs), and must <b>always</b> update the signals which it assigns (outputs):
<pre><code class="vhdl">process(A, B, SEL)
begin
  Z &lt;= B;
  if SEL='1' then
    Z &lt;= A;
  end if;
end process;</code></pre>
              </div>
            </div>
          </div>

            <!-- Qualified Expressions -->
            <div  id="Qualified_Expressions">
            <h2>Qualified Expressions</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Expression</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Entity<br>Architecture<br>Package<br>Package Body</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">type'(expression)</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
A qualified expression is an expression with its type explicitly stated. This is necessary where it might otherwise be ambiguous:
<pre><code class="vhdl">string'("0010")
bit_vector'("0010")
std_logic_vector'("0010")</code></pre>

Qualified expressions may be required when calling <b>overloaded</b> functions or procedures. The qualification makes it clear which version is being called:
<pre><code class="vhdl">architecture OVER of A is
  signal P_STD : std_logic;
  signal P_BIT : bit;
  function PARITY (X : bit_vector) return bit is
  begin
    -- function code
  end PARITY;
  function PARITY (X : std_logic_vector) return std_logic is
  begin
    -- function code
  end PARITY;
begin
  P_BIT &lt;= PARITY(bit_vector'("00100"));
  P_STD &lt;= PARITY(std_logic_vector'("10101"));
end OVER;</code></pre>

Qualification may be necessary for certain aggregate and array expressions:
<pre><code class="vhdl">entity CONCAT is
  port(A,B : in  std_ulogic;
      VALUE: out integer range 0 to 9);
end CONCAT;

architecture BEHAVIOURAL of CONCAT is
  subtype T_2 is std_ulogic_vector(1 downto 0);
begin
  process(A,B)
  begin
    case T_2'(A &amp; B) is
      when "00"   =&gt; VALUE &lt;= 0;
      when "01"   =&gt; VALUE &lt;= 1;
      when "10"   =&gt; VALUE &lt;= 2;
      when "11"   =&gt; VALUE &lt;= 3;
      when others =&gt; VALUE &lt;= 9;
    end case;
  end process;
end BEHAVIOURAL;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Qualified expressions are usually supported bt logic synthesis tools, providing the expression is of a synthesisable type.
              </div>
            </div>
          </div>

            <!-- Signal Assignment - Concurrent -->
            <div  id="Signal_Assignment-Concurrent">
            <h2>Signal Assignment - Concurrent</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Concurrent Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Architecture</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">signal_name &lt;= expression</code></pre>
                <pre><code class="vhdl">signal_name &lt;= expression after delay;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
A concurrent signal assignment assigns a new value to the target signal whenever any of the signals on the right hand side change:
<pre><code class="vhdl">architecture CONC of HA is
begin
  SUM   &lt;= A xor B;
  CARRY &lt;= A and B;
end CONC;</code></pre>

Concurrent assignments have an "equivalent process". This is the equivalent process for the concurrent statements above.
<pre><code class="vhdl">architecture SEQ of HA is
begin
  process(A, B)
  begin
    SUM   &lt;= A xor B;
    CARRY &lt;= A and B;
  end process;
end SEQ;</code></pre>

A signal assignment may have a delay specified:
<pre><code class="vhdl">architecture DELAYS of X is
  constant PERIOD : time := 10 ns;
begin
  SUM   &lt;= A xor B after 5 ns;
  CARRY &lt;= A and B after 3 ns;
  CLK   &lt;= not CLK after PERIOD/2;
end DELAYS;</code></pre>

The default delay model is <b>inertial</b>. This means that "pulses" shorter than the delay time are not propagated. The alternative is <b>transport</b> delay, which propagates all transitions:
<pre><code class="vhdl">architecture TRANS of BUFF is
  constant DELAY : time := 10 ns;
begin
  O_PIN &lt;= transport I_PIN after DELAY;
end TRANS;</code></pre>

Multiple concurrent assignments to the same signal imply multiple drivers. A signal which is the target of multiple concurrent signal assignments must be of a resolved type, e.g. std_logic, std_logic_vector.<br/><br/>

For <b>guarded assignments</b>, see <b>blocks</b>.
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Concurrent signal assignments are generally synthesisable, providing they use types and operators acceptable to the synthesis tool.<br/><br/>

                A signal assigned with a concurrent statemant will be inferred as combinational logic.<br/><br/>

                Guarded assignments are not usually supported, and delays are ignored.
              </div>
            </div>
          </div>

            <!-- Signal Assignment - Conditional -->
            <div  id="Signal_Assignment-Conditional">
            <h2>Signal Assignment - Conditional</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Concurrent Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Architecture</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">signal_name &lt;= expression_1 when condition_1 else
               expression_2 when condition_2 else
               expression_3;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
Each condition is aboolean expression:
<pre><code class="vhdl">architecture COND of BRANCH is
begin
  Z &lt;= A when X &gt; 5 else
       B when X &gt; 5 else
       C;
end COND;</code></pre>

Conditions may overlap, as for the if statement. The expression corresponding to the first "true" condition is assigned.
<pre><code class="vhdl">architecture COND of BRANCH is
begin
  Z &lt;= A when X = 5 else
       B when X &lt; 10 else
       C;
end COND;</code></pre>

There must be a final unconditional <b>else</b> expression:
<pre><code class="vhdl">architecture COND of WRONG is
begin
  Z &lt;= A when X &gt; 5;  --illegal
end COND;</code></pre>

The expressions assigned may be delayed. Transport delay mode may also be specified.<br/><br/>

Conditional signal assigments may be used to define <b>tri-state buffers</b>, using the <b>std_logic</b> and <b>std_logic_vector</b> type. Note the use of the aggregate form for a vector bus.
<pre><code class="vhdl">architecture COND of TRI_STATE is
  signal TRI_BIT : std_logic;
  signal TRI_BUS : std_logic_vector(0 to 7);
begin
  TRI_BIT &lt;= BIT_1 when EN_1 = '1' else 'Z';
  TRI_BUS &lt;= BUS_1 when EN_2 = '1' else (others =&gt; 'Z');
end COND;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Conditional signal assignments are generally synthesisable.<br/><br/>

                A conditional signal assignment will usually result in combinational logic being generated. Assignment to 'Z' will normally generate tri-state drivers. Assinment to 'X' may not be supported.<br/><br/>

                If a signal is conditionally assigned to itself, latches may be inferred.
              </div>
            </div>
          </div>

            <!-- Signal Assignment - Sequential -->
            <div  id="Signal_Assignment-Sequential">
            <h2>Signal Assignment - Sequential</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Sequential Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Process<br>Procedure</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">signal_name &lt;= expression;</code></pre>
                <pre><code class="vhdl">signal_name &lt;= expression after delay;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
A sequential signal assignment takes effect only when the process suspends. If there is more than one assignment to the same signal before suspension, the last one executed takes effect:
<pre><code class="vhdl">process(A, B, SEL)
begin
  Z &lt;= B;
  if SEL='1' then
    Z &lt;= A;
  end if;
end process;</code></pre>

An equivalent process:
<pre><code class="vhdl">process (A, B, SEL)
begin
  if SEL='1' then
    Z &lt;= A;
  else
    Z &lt;= B;
  end if;
end process;</code></pre>

If a signal which has assignments to it within a process is also in the sensitivity list, it may cause the process to be reactivated:
<pre><code class="vhdl">architecture EX1 of V is
  signal A,B,M,N,Y,Z : integer;
begin
  process(A, B, M, N)
  begin
    M &lt;= A;
    N &lt;= B;
    Z &lt;= M + N;
    M &lt;= 2*A;
    Y &lt;= M + N;
  end process;
end EX1;</code></pre>

In this architecture, the signals Y and Z will both get the same value (2*A + B) because even though two assignments to the signal M are executed, the first will always be superceded by the second.<br/><br/>

A sequential signal assignment may have a delay:
<pre><code class="vhdl">process(A, B)
begin
  SUM   &lt;= A xor B after 1.7 ns;
  CARRY &lt;= A and B after 1.2 ns;
end process;</code></pre>

The rules about what happpens when a delayed signal assignment is subsequently overridden are complex. A delayed sequential signal assignment does <b>not</b> suspend the process or procedure for the time specified. The assignment is <b>scheduled</b> to occur after the specified time, and any further sequential statements are executed immediately
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Sequential signal assignments are generally synthesisable, providing they use types and operators acceptable to the synthesis tool. Delays are usually ignored.<br/><br/>

                All signals with assignments to them within a "clocked process" will become the outputs of registers in the synthesised design.<br/><br/>

                Signals driven by a "combinational process" will be inferred as the outputs of combinational logic <b>but</b> a signal which is assigned only under certain conditions may infer a latch. Assignment to 'Z' will normally generate tri-state drivers. assignment to 'X' may not be supported.
              </div>
            </div>
          </div>

            <!-- Signal Declaration -->
            <div  id="Signal_Declaration">
            <h2>Signal Declaration</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Declaration</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Architecture</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">signal signal_name : type;</code></pre>
                <pre><code class="vhdl">signal signal_name : type := initial_value;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">signal SUM, CARRY1, CARRY2 : bit;
signal COUNT : integer range 0 to 15;
signal CLK, RESET : std_ulogic := '0';
signal ALARM_TIME : T_CLOCK_TIME := (1,2,0,0);
signal CONDITION : boolean := false;</code></pre>

During elaboration, eacg signal is set to an initial value. If a signal is not given an explicit initial value, it will default to the leftmost value (<b>'left</b>) of its declared type:
<pre><code class="vhdl">signal I : integer range 0 to 3; -- I will initialise to 0
signal X : std_logic; -- X will initialise to 'U'</code></pre>

A signal which is driven by more than one process, concurrentstatement or component instance, must be declared with a <b>resolved type</b>, e.g.std_logic or std_logic_vector:
<pre><code class="vhdl">architecture COND of TRI_STATE is
  signal TRI_BIT: std_logic;
begin
  TRI_BIT &lt;= BIT_1 when EN_1 = '1' else 'Z';
  TRI_BIT &lt;= BIT_2 when EN_2 = '1' else 'Z';
end COND;</code></pre>

Signals may not be declared in a processor subprogram (except as formal parameters).<br/><br/>

Ports declared in an entity are accessible as signals within the associated architecture(s) and do not need to be redeclared.<br/><br/>

A signal of a <b>resolved type</b> may be declared as a <b>guarded resolved</b> signal. This is required if all drivers to a signal may be turned off, through guarded assignments.
<pre><code class="vhdl">signal signal_name : resolved_type signal_kind;</code></pre>

The "signal kind" keyword may be <b>register</b> or <b>bus</b>. Guarded resolved signals of kind <b>register</b> retain their current value when drive is turned off, whereas signals of kind <b>bus</b> rely on the resolution function to provide a "no-drive" value.
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Signals are supported for synthesis, providing they are of a type acceptable to the logic synthesis tool.<br/><br/>

                The signal kinds <b>register</b> of <b>bus</b> are usually ignored.<br/><br/>

                Only certain resolved signal types are supported. Most tools recognise the <b>std_logic_1164</b> types.
              </div>
            </div>
          </div>

            <!-- Subtype Declaration -->
            <div  id="Subtype_Declaration">
            <h2>Subtype Declaration</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Declaration</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Package<br>Entity<br>Architecture<br>Process<br>Procedure<br>Function</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">subtype subtype_name is base_type range range_constraint;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
Assignments may not be made between objects of different types even though they may be similar.
<pre><code class="vhdl">type BUS_VAL is range 0 to 255;
type MY_LOGIC is ('0','1');

variable X_INT : integer := 22;
variable X_BUS : BUS_VAL := 22;
variable X_BIT : bit := '0';
variable X_MY  : MY_LOGIC := '0';
...
X_BUS := X_INT; --illegal
X_MY  := X_BIT; --illegal</code></pre>

Since a subtype is the <b>same type</b> as its base type, assignments between subtype and base type onjects can be made without conversion:
<pre><code class="vhdl">subtype BUS_VAL is integer range 0 to 255;
subtype MY_LOGIC is std_ulogic range 'X' to 'Z';
variable X_INT : integer    := 22;
variable X_BUS : BUS_VAL;
variable X_STD : std_ulogic := '0';
variable X_MY  : MY_LOGIC;
...
X_BUS := X_INT; --legal
X_MY  := X_STD; --legal</code></pre>

Subtypes <b>natural</b> and <b>positive</b> are predefined subtypes of <b>integer</b>
<pre><code class="vhdl">subtype NATURAL is integer range 0 to integer'high;
subtype POSITIVE is integer range 1 to integer'high;</code></pre>

The std_logic_1164 package defines the following subtypes of <b>std_logic</b>:
<pre><code class="vhdl">subtype XO1  is std_ulogic range 'X' to '1';
subtype XO1Z is std_ulogic range 'X' to 'Z';
subtype UXO1 is std_ulogic range 'U' to '1';</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Most logic synthesis tools support subtypes of types that they recognise.<br/><br/>

                Synthesis tools will infer an appropriate number of bits for enumerated and integer subtypes, depending on the range.
              </div>
            </div>
          </div>

            <!-- Type Conversion -->
            <div  id="Type_Conversion">
            <h2>Type Conversion</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Expression</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Package<br>Entity<br>Architecture<br>Process<br>Procedure<br>Function</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">target_type (closely_related_expression)</code></pre>
                <pre><code class="vhdl">conversion_function (expression)</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
Objects of user-defined types cannot directly be assigned to or from objects of even a closely related type. A <b>type conversion</b> allows the assignment to be made:
<pre><code class="vhdl">type BUS_VAL is range 0 to 255;

variable X_INT : integer := 22;
variable X_BUS : BUS_VAL;
...
X_BUS := X_INT; -- illegal
X_BUS := BUS_VAL(X_INT);</code></pre>

<b>Closely related types</b> are:
<ol>
<li>integer types and real types
</li><li>array types whose lengths, index types and element types match.
</li></ol>
For instance:
<pre><code class="vhdl">type T_BYTE is array (7 downto 0) of std_ulogic;
signal TYPE_BUS : T_BYTE;
signal VEC_BUS : std_ulogic_vector(7 downto 0);
...
TYPE_BUS &lt;= VEC_BUS; -- illegal
TYPE_BUS &lt;= T_BYTE(VEC_BUS);</code></pre>

If conversion is required between types which are not closely related, a user defined function must be used:
<pre><code class="vhdl">signal X_BOOL : boolean;
signal X_STD : std_ulogic;
function BOOL_TO_SL(X : boolean) return std_ulogic is
begin
  if X then
    return ('1');
  else
    return ('0');
  end if;
end BOOL_TO_SL;
...
X_STD &lt;= X_BOOL; -- illegal
X_STD &lt;= BOOL_TO_SL(X_BOOL);</code></pre>

A type conversion function may be called in a port map, to match port type to signal type.
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Most logic synthesis tools support type conversion for appropriate array and integer types.<br/><br/>

                Most also accept the type conversion functions in the std_logic_1164 package.<br/><br/>

                Some synthesis vendors supply a VHDL package containing conversion functions which the synthesiser will spuuort.<br/><br/>

                Conversion functions in port maps are not usually supported.
              </div>
            </div>
          </div>

            <!-- Use Clause -->
            <div  id="Use_Clause">
            <h2>Use Clause</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Context Clause</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Entity<br>Architecture<br>Package<br>Configuration</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">use library_name.primary_unit_name;</code></pre>
                <pre><code class="vhdl">use library_name.primary_unit_name.item;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
The use clause must appear before the start of the design unit itself. If the unit to be used is not in the library <b>work</b>, it must be preceded by a library clause:
<pre><code class="vhdl">library IEEE;
use IEEE.STD_LOGIC_1164.all;
entity WIDGET is

-- etc.

end WIDGET;</code></pre>

The use clause is valid only for the design unit immediately following it in the design file. However it also automatically applies to any secondary units associated with primary units for which it is valid.<br/><br/>

Where multiple primary design units in the same design file need to use the same items, the use clause(s) must be repeated before each unit.<br/><br/>

The last field in a use clause may be replaced by <b>all</b> to access all items in a design unit, or all design unitsin a library:
<pre><code class="vhdl">library MY_LIB;
use MY_LIB.MY_PACK.all;</code></pre>

The shorter form of the use clause may appear in a configuration, to select which library entities are selected from:
<pre><code class="vhdl">library ASIC_LIB;
configuration ASIC_TECH of ENT is
  for GATE_ARCH
    use ASIC_LIB.all;
  end for;
end ASIC_TECH;</code></pre>

The shorter form of the use clause may also appear in the declarative part of an entity, architecture or block.
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                The use clause is usually supported by synthesis tools, but design libraries are often not.<br/><br/>

                Design files corresponding to any design units referenced by a use clause must be analysed before the design units referencing them can be synthesised.
              </div>
            </div>
          </div>

            <!-- Variable Declaration -->
            <div  id="Variable_Declaration">
            <h2>Variable Declaration</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Declaration</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Process<br>Procedure<br>Function</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">variable variable_name : type;</code></pre>
                <pre><code class="vhdl">variable variable_name : type := initial_value;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">variable HEIGHT : integer := 8;
variable COND : boolean := true;
variable IN_STRING : string(1 to 80);
variable M,N : bit := '1';
variable I : integer range 0 to 3;
variable MAKE_FRAME_STATE : T_MAKE_FRAME_STATE := RCV_HIGH;</code></pre>

A Variable may be given an explicit initial value when it is declared. If a variable is not given an explicit value, it's default value will be the leftmost value (<b>'left</b>) of its declared type.
<pre><code class="vhdl">variable I : integer range 0 to 3; -- initial value of I is 0
variable X : std_ulogic; -- initial value of X is 'U'</code></pre>

Variables within subprograms (functions and procedures) are initialised each time the subprogram is called:
<pre><code class="vhdl">function PARITY (X : std_ulogic_vector) return std_ulogic is
  variable TMP : std_ulogic := '0';
begin
  for J in X'range loop
    TMP := TMP xor X(J);
  end loop; --no need to initialise TMP
  return TMP;
end PARITY;</code></pre>

Variables in processes, except for "FOR LOOP" variables, receive their initial values at the start of the simulation time (time = 0 ns)
<pre><code class="vhdl">process(A)
  variable TMP : std_ulogic := '0';
begin
  TMP := '0';
  -- in this example we need to reset
  -- TMP to '0' each time the process
  -- is activated
  for I in A'low to A'high loop
    TMP := TMP xor A(I);
  end loop;
  ODD &lt;= TMP;
end process;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Variables are supported for synthesis, providing they are of a type acceptable to the logic synthesis tool.<br/><br/>

                In a "clocked process", each variable which has its value read before it has had an assignment to it will be synthesised as the output of a register.<br/><br/>

                In a "combinational process", reading a variable before it has had an assignment may cause a latch to be synthesised.<br/><br/>

                Variables declared in a subprogram are synthesised as combinational logic.
              </div>
            </div>
          </div>

            <!-- Variable Assignment -->
            <div  id="Variable_Assignment">
            <h2>Variable Assignment</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Sequential Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Process<br>Procedure<br>Function</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">variable_name := expression;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
Assignments may be made from signals to variables and vice-versa, providing the types match:
<pre><code class="vhdl">process(A, B, C, SEL)
  variable X : integer range 0 to 7;
begin
  if SEL = '1' then
    X := B;
  else
    X := C;
  end if;
  Z &lt;= A + X;
end process;</code></pre>

A variable assignment takes effect immediately:
<pre><code class="vhdl">architecture EX1 of V is
  signal A,B,Y,Z : integer;
begin
  process(A, B)
    variable M, N : integer;
  begin
    M := A;
    N := B;
    Z &lt;= M + N;
    M := 2*A;
    Y &lt;= M + N;
  end process;
end EX1;</code></pre>

An equivalent architecture with concurrent signal assignments
<pre><code class="vhdl">architecture EX2 of V is
  signal A,B,Y,Z:integer;
begin
  Z &lt;= A + B;
  Y &lt;= 2 * A + B;
end EX2;</code></pre>

A variable assignment may not be given a delay.<br/><br/>

A variable in a process can act as a register, if it is read before it has been written to, since it retains its value between sucessive process activations.
<pre><code class="vhdl">process(CLK)
  variable Q : std_ulogic;
begin
  if CLK'event and CLK='1' then
    PULSE &lt;= D and not(Q);
    Q := D;
    -- PULSE and Q act as registers
  end if;
end process;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Variable assignments are generally synthesisable, providing they use types and operators acceptable to the synthesis tool.<br/><br/>

                In a "clocked process", each variable which has its value read before it has had an assignment to it will be synthesised as the output of a register.<br/><br/>

                In a "combinational process", reading a variable before it has had an assignment may cause a latch to be synthesised.<br/><br/>

                Variables declared in a subprogram are synthesised as combinational logic.
              </div>
            </div>
          </div>

            <!-- Wait Statement -->
            <div  id="Wait_Statement">
            <h2>Wait Statement</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Sequential Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Process<br>Procedure</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
                <pre><code class="vhdl">wait until condition;</code></pre>
                <pre><code class="vhdl">wait on signal_list;</code></pre>
                <pre><code class="vhdl">wait for time;</code></pre>
                <pre><code class="vhdl">wait;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
The <b>wait until</b> form suspends a process until a change occurs on one or more of the signals in the statement and the condition is evaluated to be true. A rising edge on NET_DATA_VALID and three rising edges on CLK must occur for this process to cycle:
<pre><code class="vhdl">READ_NET: process
begin
  wait until NET_DATA_VALID = '1';
  NET_DATA_READ &lt;= '1';
  wait until CLK='1';
  wait until CLK='1';
  NET_BUFFER &lt;= NET_DATA_IN;
  wait until CLK='1';
  NET_DATA_READ &lt;= '0';
end process READ_NET;</code></pre>

The 'event term in the following form of wait statement is in fact redundant, but is required by many synthesis tools:
<pre><code class="vhdl">WAIT_PROC: process
begin
  wait until CLK'event and CLK='1';
  Q1 &lt;= D1;
end process;</code></pre>

The <b>wait on</b> form is equivalent to a sensitivity list. These processes will behave identically:
<pre><code class="vhdl">process(A, B)
begin
  -- sequential statements
end process;

process
begin
  -- identical statements
  wait on A, B;
end process;</code></pre>

The <b>wait</b> statement <b>cannot</b> be used:
<ol>
  <li>In a process with a sensitivity list</li>
  <li>In a procedure called from a process with a sensitivity list.</li>
  <li>In a function</li>
  <li>In a procedure called from a function</li>
</ol><br/><br/>
<b>Wait for</b> and <b>wait</b> are useful in behavioural models and test benches. <b>Wait</b> on it's own suspends a process indefinitely:
<pre><code class="vhdl">STIMULUS: process
begin
  EN_1 &lt;= '0';
  EN_2 &lt;= '1';
  wait for 10 ns;
  EN_1 &lt;= '1';
  EN_2 &lt;= '0';
  wait for 10 ns;
  EN_1 &lt;= '0';
  wait for 10 ns;
  wait; -- end of test
end process STIMULUS;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                Most logic synthesis tools only support a single <b>wait until</b> (clock edge expression) statement in a "clocked process".<br/><br/>

                Some tools support a single <b>wait on</b> statement as an alternative to a sensitive list in a "combinational process".<br/><br/>

                <b>Wait for</b>, unconditional <b>wait</b> and wait statements in procedures are not supported.
              </div>
            </div>
          </div>

            <!-- While and Infinite Loop -->
            <div  id="While_and_Infinite_Loop">
            <h2>While and Infinite Loop</h2>

            <!-- USE -->
            <table border="0" cellpadding="15">
              <tr>
                <td bgcolor="lightcyan">Sequential Statement</td>
                <td>---- used in ----&gt;</td>
                <td bgcolor="lightgreen">Process<br>Function<br>Procedure</td>
              </tr>
            </table><br>

            <!-- SYNTAX -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Syntax</h3>
              </div>
              <div class="panel-body">
<pre><code class="vhdl">while condition loop
  sequential statements
end loop;</code></pre>
<pre><code class="vhdl">loop
  sequential statements
end loop;</code></pre>
              </div>
            </div>

            <!-- RULES AND EXAMPLES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Rules and Examples</h3>
              </div>
              <div class="panel-body">
The <b>while</b> loop repeats the enclosed sequence of statements if the condition tested is true. The condition is tested before wach iteration.
<pre><code class="vhdl">process(A)
  variable I : integer range 0 to 4;
begin
  Z &lt;= "0000";
  I := 0;
  while (I &lt;= 3) loop
    if (A = I) then
      Z(I) &lt;= '1';
    end if;
    I := I + 1;
  end loop;
end process;</code></pre>

While loops may be useful in test benches:
<pre><code class="vhdl">process
begin
  while NOW &lt; MAX_SIM_TIME loop
    CLK &lt;= not CLK ;
    wait for PERIOD/2;
  end loop;
  wait;
end process;</code></pre>

To prevent simulation hang-up an infinite loop should usually contain at least one wait or exit statement:
<pre><code class="vhdl">process (A)
  variable I : integer range 0 to 4;
begin
  Z &lt;= "0000";
  I := 0;
  L1 : loop
    exit L1 when I = 4;
    if (A = I) then
      Z(I) &lt;= '1';
    end if;
    I := I + 1;
  end loop;
end process;</code></pre>
              </div>
            </div>

            <!-- SYNTHESIS ISSUES -->
            <div class="panel panel-default">
              <div class="panel-heading">
                <h3 class="panel-title">Synthesis Issues</h3>
              </div>
              <div class="panel-body">
                While and infinite loops are supported by some logic synthesis tools, with certain restrictions.
              </div>
            </div>
          </div>
            <!-- <a href="#menu-toggle" class="btn btn-default" id="menu-toggle">Toggle Menu</a> -->
          </div>
        </div>
      </div>
    </div><!-- /#page-content-wrapper -->
  </div><!-- /#wrapper -->
</body>

</html>
